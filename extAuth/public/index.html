<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LinksBook Extension Auth</title>
    <!-- <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="geist.css">
    <link rel="stylesheet" href="dialog.css">
    <script src="dialog.js"></script>
    <script src="main.js" defer></script> -->

    <script>
        (function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.dialogPolyfill = factory());
}(this, function () { 'use strict';

  // nb. This is for IE10 and lower _only_.
  var supportCustomEvent = window.CustomEvent;
  if (!supportCustomEvent || typeof supportCustomEvent === 'object') {
    supportCustomEvent = function CustomEvent(event, x) {
      x = x || {};
      var ev = document.createEvent('CustomEvent');
      ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);
      return ev;
    };
    supportCustomEvent.prototype = window.Event.prototype;
  }

  /**
   * Dispatches the passed event to both an "on<type>" handler as well as via the
   * normal dispatch operation. Does not bubble.
   *
   * @param {!EventTarget} target
   * @param {!Event} event
   * @return {boolean}
   */
  function safeDispatchEvent(target, event) {
    var check = 'on' + event.type.toLowerCase();
    if (typeof target[check] === 'function') {
      target[check](event);
    }
    return target.dispatchEvent(event);
  }

  /**
   * @param {Element} el to check for stacking context
   * @return {boolean} whether this el or its parents creates a stacking context
   */
  function createsStackingContext(el) {
    while (el && el !== document.body) {
      var s = window.getComputedStyle(el);
      var invalid = function(k, ok) {
        return !(s[k] === undefined || s[k] === ok);
      };

      if (s.opacity < 1 ||
          invalid('zIndex', 'auto') ||
          invalid('transform', 'none') ||
          invalid('mixBlendMode', 'normal') ||
          invalid('filter', 'none') ||
          invalid('perspective', 'none') ||
          s['isolation'] === 'isolate' ||
          s.position === 'fixed' ||
          s.webkitOverflowScrolling === 'touch') {
        return true;
      }
      el = el.parentElement;
    }
    return false;
  }

  /**
   * Finds the nearest <dialog> from the passed element.
   *
   * @param {Element} el to search from
   * @return {HTMLDialogElement} dialog found
   */
  function findNearestDialog(el) {
    while (el) {
      if (el.localName === 'dialog') {
        return /** @type {HTMLDialogElement} */ (el);
      }
      if (el.parentElement) {
        el = el.parentElement;
      } else if (el.parentNode) {
        el = el.parentNode.host;
      } else {
        el = null;
      }
    }
    return null;
  }

  /**
   * Blur the specified element, as long as it's not the HTML body element.
   * This works around an IE9/10 bug - blurring the body causes Windows to
   * blur the whole application.
   *
   * @param {Element} el to blur
   */
  function safeBlur(el) {
    // Find the actual focused element when the active element is inside a shadow root
    while (el && el.shadowRoot && el.shadowRoot.activeElement) {
      el = el.shadowRoot.activeElement;
    }

    if (el && el.blur && el !== document.body) {
      el.blur();
    }
  }

  /**
   * @param {!NodeList} nodeList to search
   * @param {Node} node to find
   * @return {boolean} whether node is inside nodeList
   */
  function inNodeList(nodeList, node) {
    for (var i = 0; i < nodeList.length; ++i) {
      if (nodeList[i] === node) {
        return true;
      }
    }
    return false;
  }

  /**
   * @param {HTMLFormElement} el to check
   * @return {boolean} whether this form has method="dialog"
   */
  function isFormMethodDialog(el) {
    if (!el || !el.hasAttribute('method')) {
      return false;
    }
    return el.getAttribute('method').toLowerCase() === 'dialog';
  }

  /**
   * @param {!DocumentFragment|!Element} hostElement
   * @return {?Element}
   */
  function findFocusableElementWithin(hostElement) {
    // Note that this is 'any focusable area'. This list is probably not exhaustive, but the
    // alternative involves stepping through and trying to focus everything.
    var opts = ['button', 'input', 'keygen', 'select', 'textarea'];
    var query = opts.map(function(el) {
      return el + ':not([disabled])';
    });
    // TODO(samthor): tabindex values that are not numeric are not focusable.
    query.push('[tabindex]:not([disabled]):not([tabindex=""])');  // tabindex != "", not disabled
    var target = hostElement.querySelector(query.join(', '));

    if (!target && 'attachShadow' in Element.prototype) {
      // If we haven't found a focusable target, see if the host element contains an element
      // which has a shadowRoot.
      // Recursively search for the first focusable item in shadow roots.
      var elems = hostElement.querySelectorAll('*');
      for (var i = 0; i < elems.length; i++) {
        if (elems[i].tagName && elems[i].shadowRoot) {
          target = findFocusableElementWithin(elems[i].shadowRoot);
          if (target) {
            break;
          }
        }
      }
    }
    return target;
  }

  /**
   * Determines if an element is attached to the DOM.
   * @param {Element} element to check
   * @return {boolean} whether the element is in DOM
   */
  function isConnected(element) {
    return element.isConnected || document.body.contains(element);
  }

  /**
   * @param {!Event} event
   * @return {?Element}
   */
  function findFormSubmitter(event) {
    if (event.submitter) {
      return event.submitter;
    }

    var form = event.target;
    if (!(form instanceof HTMLFormElement)) {
      return null;
    }

    var submitter = dialogPolyfill.formSubmitter;
    if (!submitter) {
      var target = event.target;
      var root = ('getRootNode' in target && target.getRootNode() || document);
      submitter = root.activeElement;
    }

    if (!submitter || submitter.form !== form) {
      return null;
    }
    return submitter;
  }

  /**
   * @param {!Event} event
   */
  function maybeHandleSubmit(event) {
    if (event.defaultPrevented) {
      return;
    }
    var form = /** @type {!HTMLFormElement} */ (event.target);

    // We'd have a value if we clicked on an imagemap.
    var value = dialogPolyfill.imagemapUseValue;
    var submitter = findFormSubmitter(event);
    if (value === null && submitter) {
      value = submitter.value;
    }

    // There should always be a dialog as this handler is added specifically on them, but check just
    // in case.
    var dialog = findNearestDialog(form);
    if (!dialog) {
      return;
    }

    // Prefer formmethod on the button.
    var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');
    if (formmethod !== 'dialog') {
      return;
    }
    event.preventDefault();

    if (value != null) {
      // nb. we explicitly check against null/undefined
      dialog.close(value);
    } else {
      dialog.close();
    }
  }

  /**
   * @param {!HTMLDialogElement} dialog to upgrade
   * @constructor
   */
  function dialogPolyfillInfo(dialog) {
    this.dialog_ = dialog;
    this.replacedStyleTop_ = false;
    this.openAsModal_ = false;

    // Set a11y role. Browsers that support dialog implicitly know this already.
    if (!dialog.hasAttribute('role')) {
      dialog.setAttribute('role', 'dialog');
    }

    dialog.show = this.show.bind(this);
    dialog.showModal = this.showModal.bind(this);
    dialog.close = this.close.bind(this);

    dialog.addEventListener('submit', maybeHandleSubmit, false);

    if (!('returnValue' in dialog)) {
      dialog.returnValue = '';
    }

    if ('MutationObserver' in window) {
      var mo = new MutationObserver(this.maybeHideModal.bind(this));
      mo.observe(dialog, {attributes: true, attributeFilter: ['open']});
    } else {
      // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also
      // seem to fire even if the element was removed as part of a parent removal. Use the removed
      // events to force downgrade (useful if removed/immediately added).
      var removed = false;
      var cb = function() {
        removed ? this.downgradeModal() : this.maybeHideModal();
        removed = false;
      }.bind(this);
      var timeout;
      var delayModel = function(ev) {
        if (ev.target !== dialog) { return; }  // not for a child element
        var cand = 'DOMNodeRemoved';
        removed |= (ev.type.substr(0, cand.length) === cand);
        window.clearTimeout(timeout);
        timeout = window.setTimeout(cb, 0);
      };
      ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function(name) {
        dialog.addEventListener(name, delayModel);
      });
    }
    // Note that the DOM is observed inside DialogManager while any dialog
    // is being displayed as a modal, to catch modal removal from the DOM.

    Object.defineProperty(dialog, 'open', {
      set: this.setOpen.bind(this),
      get: dialog.hasAttribute.bind(dialog, 'open')
    });

    this.backdrop_ = document.createElement('div');
    this.backdrop_.className = 'backdrop';
    this.backdrop_.addEventListener('mouseup'  , this.backdropMouseEvent_.bind(this));
    this.backdrop_.addEventListener('mousedown', this.backdropMouseEvent_.bind(this));
    this.backdrop_.addEventListener('click'    , this.backdropMouseEvent_.bind(this));
  }

  dialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */ ({

    get dialog() {
      return this.dialog_;
    },

    /**
     * Maybe remove this dialog from the modal top layer. This is called when
     * a modal dialog may no longer be tenable, e.g., when the dialog is no
     * longer open or is no longer part of the DOM.
     */
    maybeHideModal: function() {
      if (this.dialog_.hasAttribute('open') && isConnected(this.dialog_)) { return; }
      this.downgradeModal();
    },

    /**
     * Remove this dialog from the modal top layer, leaving it as a non-modal.
     */
    downgradeModal: function() {
      if (!this.openAsModal_) { return; }
      this.openAsModal_ = false;
      this.dialog_.style.zIndex = '';

      // This won't match the native <dialog> exactly because if the user set top on a centered
      // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's
      // possible to polyfill this perfectly.
      if (this.replacedStyleTop_) {
        this.dialog_.style.top = '';
        this.replacedStyleTop_ = false;
      }

      // Clear the backdrop and remove from the manager.
      this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);
      dialogPolyfill.dm.removeDialog(this);
    },

    /**
     * @param {boolean} value whether to open or close this dialog
     */
    setOpen: function(value) {
      if (value) {
        this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');
      } else {
        this.dialog_.removeAttribute('open');
        this.maybeHideModal();  // nb. redundant with MutationObserver
      }
    },

    /**
     * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if
     * they were on the dialog itself.
     *
     * @param {!Event} e to redirect
     */
    backdropMouseEvent_: function(e) {
      if (!this.dialog_.hasAttribute('tabindex')) {
        // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be
        // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this
        // would not be needed - clicks would move the implicit cursor there.
        var fake = document.createElement('div');
        this.dialog_.insertBefore(fake, this.dialog_.firstChild);
        fake.tabIndex = -1;
        fake.focus();
        this.dialog_.removeChild(fake);
      } else {
        this.dialog_.focus();
      }

      var redirectedEvent = document.createEvent('MouseEvents');
      redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window,
          e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey,
          e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
      this.dialog_.dispatchEvent(redirectedEvent);
      e.stopPropagation();
    },

    /**
     * Focuses on the first focusable element within the dialog. This will always blur the current
     * focus, even if nothing within the dialog is found.
     */
    focus_: function() {
      // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.
      var target = this.dialog_.querySelector('[autofocus]:not([disabled])');
      if (!target && this.dialog_.tabIndex >= 0) {
        target = this.dialog_;
      }
      if (!target) {
        target = findFocusableElementWithin(this.dialog_);
      }
      safeBlur(document.activeElement);
      target && target.focus();
    },

    /**
     * Sets the zIndex for the backdrop and dialog.
     *
     * @param {number} dialogZ
     * @param {number} backdropZ
     */
    updateZIndex: function(dialogZ, backdropZ) {
      if (dialogZ < backdropZ) {
        throw new Error('dialogZ should never be < backdropZ');
      }
      this.dialog_.style.zIndex = dialogZ;
      this.backdrop_.style.zIndex = backdropZ;
    },

    /**
     * Shows the dialog. If the dialog is already open, this does nothing.
     */
    show: function() {
      if (!this.dialog_.open) {
        this.setOpen(true);
        this.focus_();
      }
    },

    /**
     * Show this dialog modally.
     */
    showModal: function() {
      if (this.dialog_.hasAttribute('open')) {
        throw new Error('Failed to execute \'showModal\' on dialog: The element is already open, and therefore cannot be opened modally.');
      }
      if (!isConnected(this.dialog_)) {
        throw new Error('Failed to execute \'showModal\' on dialog: The element is not in a Document.');
      }
      if (!dialogPolyfill.dm.pushDialog(this)) {
        throw new Error('Failed to execute \'showModal\' on dialog: There are too many open modal dialogs.');
      }

      if (createsStackingContext(this.dialog_.parentElement)) {
        console.warn('A dialog is being shown inside a stacking context. ' +
            'This may cause it to be unusable. For more information, see this link: ' +
            'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');
      }

      this.setOpen(true);
      this.openAsModal_ = true;

      // Optionally center vertically, relative to the current viewport.
      if (dialogPolyfill.needsCentering(this.dialog_)) {
        dialogPolyfill.reposition(this.dialog_);
        this.replacedStyleTop_ = true;
      } else {
        this.replacedStyleTop_ = false;
      }

      // Insert backdrop.
      this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);

      // Focus on whatever inside the dialog.
      this.focus_();
    },

    /**
     * Closes this HTMLDialogElement. This is optional vs clearing the open
     * attribute, however this fires a 'close' event.
     *
     * @param {string=} opt_returnValue to use as the returnValue
     */
    close: function(opt_returnValue) {
      if (!this.dialog_.hasAttribute('open')) {
        throw new Error('Failed to execute \'close\' on dialog: The element does not have an \'open\' attribute, and therefore cannot be closed.');
      }
      this.setOpen(false);

      // Leave returnValue untouched in case it was set directly on the element
      if (opt_returnValue !== undefined) {
        this.dialog_.returnValue = opt_returnValue;
      }

      // Triggering "close" event for any attached listeners on the <dialog>.
      var closeEvent = new supportCustomEvent('close', {
        bubbles: false,
        cancelable: false
      });
      safeDispatchEvent(this.dialog_, closeEvent);
    }

  });

  var dialogPolyfill = {};

  dialogPolyfill.reposition = function(element) {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;
    element.style.top = Math.max(scrollTop, topValue) + 'px';
  };

  dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {
    for (var i = 0; i < document.styleSheets.length; ++i) {
      var styleSheet = document.styleSheets[i];
      var cssRules = null;
      // Some browsers throw on cssRules.
      try {
        cssRules = styleSheet.cssRules;
      } catch (e) {}
      if (!cssRules) { continue; }
      for (var j = 0; j < cssRules.length; ++j) {
        var rule = cssRules[j];
        var selectedNodes = null;
        // Ignore errors on invalid selector texts.
        try {
          selectedNodes = document.querySelectorAll(rule.selectorText);
        } catch(e) {}
        if (!selectedNodes || !inNodeList(selectedNodes, element)) {
          continue;
        }
        var cssTop = rule.style.getPropertyValue('top');
        var cssBottom = rule.style.getPropertyValue('bottom');
        if ((cssTop && cssTop !== 'auto') || (cssBottom && cssBottom !== 'auto')) {
          return true;
        }
      }
    }
    return false;
  };

  dialogPolyfill.needsCentering = function(dialog) {
    var computedStyle = window.getComputedStyle(dialog);
    if (computedStyle.position !== 'absolute') {
      return false;
    }

    // We must determine whether the top/bottom specified value is non-auto.  In
    // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but
    // Firefox returns the used value. So we do this crazy thing instead: check
    // the inline style and then go through CSS rules.
    if ((dialog.style.top !== 'auto' && dialog.style.top !== '') ||
        (dialog.style.bottom !== 'auto' && dialog.style.bottom !== '')) {
      return false;
    }
    return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);
  };

  /**
   * @param {!Element} element to force upgrade
   */
  dialogPolyfill.forceRegisterDialog = function(element) {
    if (window.HTMLDialogElement || element.showModal) {
      console.warn('This browser already supports <dialog>, the polyfill ' +
          'may not work correctly', element);
    }
    if (element.localName !== 'dialog') {
      throw new Error('Failed to register dialog: The element is not a dialog.');
    }
    new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ (element));
  };

  /**
   * @param {!Element} element to upgrade, if necessary
   */
  dialogPolyfill.registerDialog = function(element) {
    if (!element.showModal) {
      dialogPolyfill.forceRegisterDialog(element);
    }
  };

  /**
   * @constructor
   */
  dialogPolyfill.DialogManager = function() {
    /** @type {!Array<!dialogPolyfillInfo>} */
    this.pendingDialogStack = [];

    var checkDOM = this.checkDOM_.bind(this);

    // The overlay is used to simulate how a modal dialog blocks the document.
    // The blocking dialog is positioned on top of the overlay, and the rest of
    // the dialogs on the pending dialog stack are positioned below it. In the
    // actual implementation, the modal dialog stacking is controlled by the
    // top layer, where z-index has no effect.
    this.overlay = document.createElement('div');
    this.overlay.className = '_dialog_overlay';
    this.overlay.addEventListener('click', function(e) {
      this.forwardTab_ = undefined;
      e.stopPropagation();
      checkDOM([]);  // sanity-check DOM
    }.bind(this));

    this.handleKey_ = this.handleKey_.bind(this);
    this.handleFocus_ = this.handleFocus_.bind(this);

    this.zIndexLow_ = 100000;
    this.zIndexHigh_ = 100000 + 150;

    this.forwardTab_ = undefined;

    if ('MutationObserver' in window) {
      this.mo_ = new MutationObserver(function(records) {
        var removed = [];
        records.forEach(function(rec) {
          for (var i = 0, c; c = rec.removedNodes[i]; ++i) {
            if (!(c instanceof Element)) {
              continue;
            } else if (c.localName === 'dialog') {
              removed.push(c);
            }
            removed = removed.concat(c.querySelectorAll('dialog'));
          }
        });
        removed.length && checkDOM(removed);
      });
    }
  };

  /**
   * Called on the first modal dialog being shown. Adds the overlay and related
   * handlers.
   */
  dialogPolyfill.DialogManager.prototype.blockDocument = function() {
    document.documentElement.addEventListener('focus', this.handleFocus_, true);
    document.addEventListener('keydown', this.handleKey_);
    this.mo_ && this.mo_.observe(document, {childList: true, subtree: true});
  };

  /**
   * Called on the first modal dialog being removed, i.e., when no more modal
   * dialogs are visible.
   */
  dialogPolyfill.DialogManager.prototype.unblockDocument = function() {
    document.documentElement.removeEventListener('focus', this.handleFocus_, true);
    document.removeEventListener('keydown', this.handleKey_);
    this.mo_ && this.mo_.disconnect();
  };

  /**
   * Updates the stacking of all known dialogs.
   */
  dialogPolyfill.DialogManager.prototype.updateStacking = function() {
    var zIndex = this.zIndexHigh_;

    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
      dpi.updateZIndex(--zIndex, --zIndex);
      if (i === 0) {
        this.overlay.style.zIndex = --zIndex;
      }
    }

    // Make the overlay a sibling of the dialog itself.
    var last = this.pendingDialogStack[0];
    if (last) {
      var p = last.dialog.parentNode || document.body;
      p.appendChild(this.overlay);
    } else if (this.overlay.parentNode) {
      this.overlay.parentNode.removeChild(this.overlay);
    }
  };

  /**
   * @param {Element} candidate to check if contained or is the top-most modal dialog
   * @return {boolean} whether candidate is contained in top dialog
   */
  dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {
    while (candidate = findNearestDialog(candidate)) {
      for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
        if (dpi.dialog === candidate) {
          return i === 0;  // only valid if top-most
        }
      }
      candidate = candidate.parentElement;
    }
    return false;
  };

  dialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {
    var target = event.composedPath ? event.composedPath()[0] : event.target;

    if (this.containedByTopDialog_(target)) { return; }

    if (document.activeElement === document.documentElement) { return; }

    event.preventDefault();
    event.stopPropagation();
    safeBlur(/** @type {Element} */ (target));

    if (this.forwardTab_ === undefined) { return; }  // move focus only from a tab key

    var dpi = this.pendingDialogStack[0];
    var dialog = dpi.dialog;
    var position = dialog.compareDocumentPosition(target);
    if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      if (this.forwardTab_) {
        // forward
        dpi.focus_();
      } else if (target !== document.documentElement) {
        // backwards if we're not already focused on <html>
        document.documentElement.focus();
      }
    }

    return false;
  };

  dialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {
    this.forwardTab_ = undefined;
    if (event.keyCode === 27) {
      event.preventDefault();
      event.stopPropagation();
      var cancelEvent = new supportCustomEvent('cancel', {
        bubbles: false,
        cancelable: true
      });
      var dpi = this.pendingDialogStack[0];
      if (dpi && safeDispatchEvent(dpi.dialog, cancelEvent)) {
        dpi.dialog.close();
      }
    } else if (event.keyCode === 9) {
      this.forwardTab_ = !event.shiftKey;
    }
  };

  /**
   * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are
   * removed and immediately readded don't stay modal, they become normal.
   *
   * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed
   */
  dialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {
    // This operates on a clone because it may cause it to change. Each change also calls
    // updateStacking, which only actually needs to happen once. But who removes many modal dialogs
    // at a time?!
    var clone = this.pendingDialogStack.slice();
    clone.forEach(function(dpi) {
      if (removed.indexOf(dpi.dialog) !== -1) {
        dpi.downgradeModal();
      } else {
        dpi.maybeHideModal();
      }
    });
  };

  /**
   * @param {!dialogPolyfillInfo} dpi
   * @return {boolean} whether the dialog was allowed
   */
  dialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {
    var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;
    if (this.pendingDialogStack.length >= allowed) {
      return false;
    }
    if (this.pendingDialogStack.unshift(dpi) === 1) {
      this.blockDocument();
    }
    this.updateStacking();
    return true;
  };

  /**
   * @param {!dialogPolyfillInfo} dpi
   */
  dialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {
    var index = this.pendingDialogStack.indexOf(dpi);
    if (index === -1) { return; }

    this.pendingDialogStack.splice(index, 1);
    if (this.pendingDialogStack.length === 0) {
      this.unblockDocument();
    }
    this.updateStacking();
  };

  dialogPolyfill.dm = new dialogPolyfill.DialogManager();
  dialogPolyfill.formSubmitter = null;
  dialogPolyfill.imagemapUseValue = null;

  /**
   * Installs global handlers, such as click listers and native method overrides. These are needed
   * even if a no dialog is registered, as they deal with <form method="dialog">.
   */
  if (window.HTMLDialogElement === undefined) {

    /**
     * If HTMLFormElement translates method="DIALOG" into 'get', then replace the descriptor with
     * one that returns the correct value.
     */
    var testForm = document.createElement('form');
    testForm.setAttribute('method', 'dialog');
    if (testForm.method !== 'dialog') {
      var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');
      if (methodDescriptor) {
        // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything
        // and don't bother to update the element.
        var realGet = methodDescriptor.get;
        methodDescriptor.get = function() {
          if (isFormMethodDialog(this)) {
            return 'dialog';
          }
          return realGet.call(this);
        };
        var realSet = methodDescriptor.set;
        /** @this {HTMLElement} */
        methodDescriptor.set = function(v) {
          if (typeof v === 'string' && v.toLowerCase() === 'dialog') {
            return this.setAttribute('method', v);
          }
          return realSet.call(this, v);
        };
        Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);
      }
    }

    /**
     * Global 'click' handler, to capture the <input type="submit"> or <button> element which has
     * submitted a <form method="dialog">. Needed as Safari and others don't report this inside
     * document.activeElement.
     */
    document.addEventListener('click', function(ev) {
      dialogPolyfill.formSubmitter = null;
      dialogPolyfill.imagemapUseValue = null;
      if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission

      var target = /** @type {Element} */ (ev.target);
      if ('composedPath' in ev) {
        var path = ev.composedPath();
        target = path.shift() || target;
      }
      if (!target || !isFormMethodDialog(target.form)) { return; }

      var valid = (target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1);
      if (!valid) {
        if (!(target.localName === 'input' && target.type === 'image')) { return; }
        // this is a <input type="image">, which can submit forms
        dialogPolyfill.imagemapUseValue = ev.offsetX + ',' + ev.offsetY;
      }

      var dialog = findNearestDialog(target);
      if (!dialog) { return; }

      dialogPolyfill.formSubmitter = target;

    }, false);

    /**
     * Global 'submit' handler. This handles submits of `method="dialog"` which are invalid, i.e.,
     * outside a dialog. They get prevented.
     */
    document.addEventListener('submit', function(ev) {
      var form = ev.target;
      var dialog = findNearestDialog(form);
      if (dialog) {
        return;  // ignore, handle there
      }

      var submitter = findFormSubmitter(ev);
      var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');
      if (formmethod === 'dialog') {
        ev.preventDefault();
      }
    });

    /**
     * Replace the native HTMLFormElement.submit() method, as it won't fire the
     * submit event and give us a chance to respond.
     */
    var nativeFormSubmit = HTMLFormElement.prototype.submit;
    var replacementFormSubmit = function () {
      if (!isFormMethodDialog(this)) {
        return nativeFormSubmit.call(this);
      }
      var dialog = findNearestDialog(this);
      dialog && dialog.close();
    };
    HTMLFormElement.prototype.submit = replacementFormSubmit;
  }

  return dialogPolyfill;

}));

    </script>
    <script>
        
            // init dialog polyfill
            const pinDialog = document.getElementById("pin-dialog");
            dialogPolyfill.registerDialog(pinDialog);


            const AUTH_SERVICE_URI = "https://celestial-unmarred-patella.glitch.me";

            async function makeRequest(host, route, body) {
                let response = await fetch(`${host}/${route}`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(body)
                });

                let data = await response.json();

                return data;
            }

            async function handleSumbit() {

                const email = document.getElementById("create-login-email").value;

                const result = await makeRequest(AUTH_SERVICE_URI, "create-login", { email });

                if (result.status === "Success") {

                    const pinDialog = document.getElementById("pin-dialog");
                    const validatePin = document.getElementById("validate-pin");
                    pinDialog.showModal();

                    // try to validate the pin
                    validatePin.addEventListener("click", async _ => {
                        const _pin = document.getElementById("pin-dialog-pin").value;
                        const lastStep = await makeRequest(AUTH_SERVICE_URI, "complete-login", { pin: _pin, email });
                        let token = lastStep.token ?? undefined;
                        if (lastStep.status === "Success") {
                            location.href = `${location.href}token/?token=${token}`
                        } else { alert("Wrong Pin. Try again."); }
                        console.log(lastStep);
                    }); // done... 

                } else { alert("Something wrong occurred.") }
            }

            const createLoginAction = document.getElementById("create-login-action");

            createLoginAction.addEventListener("click", _ => {
                handleSumbit();
            });
    </script>

    <style>
        .light,
:root {
  --accents-1: #fafafa;
  --accents-2: #eaeaea;
  --accents-3: #999;
  --accents-4: #888;
  --accents-5: #666;
  --accents-6: #444;
  --accents-7: #333;
  --accents-8: #111;
  --geist-foreground: #000;
  --geist-background: #fff;
  --geist-selection: var(--geist-cyan);
  --geist-success: #0070f3;
  --geist-success-light: #3291ff;
  --geist-success-dark: #0366d6;
  --geist-error: #e00;
  --geist-error-light: #ff1a1a;
  --geist-error-dark: #c00;
  --geist-warning: #f5a623;
  --geist-warning-light: #f7b955;
  --geist-warning-dark: #f49b0b;
  --geist-alert: #ff0080;
  --geist-purple: #f81ce5;
  --geist-cyan: #79ffe1;
  --geist-violet: #7928ca;
  --geist-link-color: var(--geist-success);
  --geist-link-style: none;
  --geist-secondary: var(--accents-5);
  --geist-code: var(--geist-purple);
  --dropdown-box-shadow: 0 4px 4px 0 rgba(0, 0, 0, 0.02);
  --dropdown-triangle-stroke: #fff;
  --scroller-start: #fff;
  --shadow-small: 0 5px 10px rgba(0, 0, 0, 0.12);
  --shadow-medium: 0 8px 30px rgba(0, 0, 0, 0.12);
  --shadow-large: 0 30px 60px rgba(0, 0, 0, 0.12);
  --portal-opacity: 0.25;
  --geist-gap: 16pt;
  --geist-gap-negative: -16pt;
  --geist-gap-half: 8pt;
  --geist-gap-half-negative: -8pt;
  --geist-gap-quarter: 4pt;
  --geist-gap-quarter-negative: -4pt;
  --geist-page-margin: 16pt;
  --geist-page-width: 750pt;
  --geist-page-width-with-margin: 782pt;
  --geist-breakpoint-mobile: 600px;
  --geist-breakpoint-tablet: 960px;
  --geist-radius: 5px;
  --font-sans: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
    "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  --font-mono: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,
    Bitstream Vera Sans Mono, Courier New, monospace;
}
.dark-theme,
.light,
:root {
  --scroller-end: hsla(0, 0%, 100%, 0);
}
.dark-theme {
  --accents-1: #111;
  --accents-2: #333;
  --accents-3: #444;
  --accents-4: #666;
  --accents-5: #888;
  --accents-6: #999;
  --accents-7: #eaeaea;
  --accents-8: #fafafa;
  --geist-foreground: #fff;
  --geist-background: #000;
  --geist-selection: var(--geist-purple);
  --geist-success: #0070f3;
  --geist-success-light: #3291ff;
  --geist-success-dark: #0366d6;
  --geist-error: #e00;
  --geist-error-light: #ff1a1a;
  --geist-error-dark: #c00;
  --geist-warning: #f5a623;
  --geist-warning-light: #f7b955;
  --geist-warning-dark: #f49b0b;
  --geist-alert: #ff0080;
  --geist-purple: #f81ce5;
  --geist-cyan: #79ffe1;
  --geist-violet: #7928ca;
  --geist-link-color: var(--geist-foreground);
  --geist-link-style: underline;
  --geist-secondary: var(--accents-5);
  --geist-code: var(--geist-cyan);
  --dropdown-box-shadow: 0 0 0 1px #333;
  --dropdown-triangle-stroke: #333;
  --scroller-start: rgba(0, 0, 0, 0.3);
  --shadow-small: 0 0 0 1px #333;
  --shadow-medium: 0 0 0 1px #333;
  --shadow-large: 0 0 0 1px #333;
  --portal-opacity: 0.75;
}
body,
html {
  background-color: var(--geist-background);
  color: var(--geist-foreground);
}
html {
  font-size: 16px;
}
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  font-size: 1rem;
  line-height: 1.5;
  margin: 0;
  padding: 0;
  min-height: 100%;
  position: relative;
  overflow-x: hidden;
  font-family: var(--font-sans);
}
*,
:after,
:before {
  box-sizing: inherit;
  text-rendering: geometricPrecision;
  -webkit-tap-highlight-color: transparent;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  margin: 0 0 0.625rem;
  color: inherit;
}
span {
  font-size: inherit;
  font-weight: inherit;
}
p,
small,
span {
  color: inherit;
}
p,
small {
  font-weight: 400;
  letter-spacing: -0.005625rem;
  font-family: var(--font-sans);
}
p {
  margin: 1rem 0;
  font-size: 1em;
  line-height: 1.625em;
}
small {
  margin: 0;
  line-height: 1.5;
  font-size: 0.875rem;
}
b {
  font-weight: 600;
}
img {
  max-width: 100%;
}
a {
  color: var(--geist-link-color);
  outline: none;
  cursor: pointer;
  font-size: inherit;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-box-align: center;
  align-items: center;
}
a,
a:hover {
  text-decoration: none;
}
button,
input,
select,
textarea {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;
  margin: 0;
}
button:focus,
input:focus,
select:focus,
textarea:focus {
  outline: none;
}
ol,
ul {
  list-style: none;
  padding: 0;
  list-style-type: none;
  margin: 8pt 8pt 8pt 16pt;
  color: var(--geist-foreground);
}
ol {
  list-style-type: decimal;
}
li {
  margin-bottom: 0.625rem;
  font-size: 1em;
  line-height: 1.625em;
}
ul > li:before {
  content: "â€“";
  display: inline-block;
  color: var(--accents-4);
  position: absolute;
  margin-left: -0.9375rem;
}
input[type="button"],
input[type="reset"],
input[type="submit"] {
  appearance: button;
}
input:-webkit-autofill {
  box-shadow: inset 0 0 0 100px #fff;
}
h1 {
  font-size: 3rem;
  letter-spacing: -0.066875rem;
  line-height: 1.5;
  font-weight: 700;
}
h2 {
  font-size: 2.25rem;
  letter-spacing: -0.020625rem;
}
h2,
h3 {
  font-weight: 600;
}
h3 {
  font-size: 1.5rem;
  letter-spacing: -0.029375rem;
}
h4 {
  font-size: 1.25rem;
  letter-spacing: -0.020625rem;
}
h4,
h5 {
  font-weight: 600;
}
h5 {
  font-size: 1rem;
  letter-spacing: -0.01125rem;
}
h6 {
  font-size: 0.875rem;
  letter-spacing: -0.005625rem;
  font-weight: 600;
}
hr {
  border-color: var(--accents-2);
}
details {
  background-color: var(--accents-1);
  border: none;
}
details:active,
details:focus,
details:hover,
summary {
  outline: none;
}
summary {
  cursor: pointer;
  user-select: none;
  list-style: none;
}
summary::-webkit-details-marker,
summary:before {
  display: none;
}
summary::-moz-list-bullet {
  font-size: 0;
}
summary:active,
summary:focus,
summary:hover {
  outline: none;
  list-style: none;
}
blockquote {
  padding: calc(0.667 * var(--geist-gap)) var(--geist-gap);
  color: var(--accents-5);
  background-color: var(--accents-1);
  border-radius: var(--geist-radius);
  margin: 1.5rem 0;
  border: 1px solid var(--accents-2);
}
blockquote :first-child {
  margin-top: 0;
}
blockquote :last-child {
  margin-bottom: 0;
}
::selection {
  background-color: var(--geist-selection);
  color: var(--geist-foreground);
}
.zi-card {
  margin: 0;
  padding: var(--geist-gap) var(--geist-gap);
  width: 100%;
  transition: all 0.2s ease;
  border-radius: var(--geist-radius);
  box-shadow: none;
  box-sizing: border-box;
  color: var(--geist-foreground);
  background-color: var(--geist-background);
  border: 1px solid var(--accents-2);
}
.zi-card:hover {
  box-shadow: var(--shadow-small);
}
.zi-card img {
  max-width: 100%;
}
.zi-card :first-child {
  margin-top: 0;
}
.zi-card :last-child {
  margin-bottom: 0;
}
.zi-card:not(.pin):hover {
  box-shadow: var(--shadow-small);
}
.zi-card.pin {
  border: 1px solid var(--accents-2);
  box-shadow: none;
}
.zi-badge {
  padding: 0 4px;
  background-color: var(--geist-foreground);
  color: var(--geist-background);
  display: inline-block;
  font-size: 0.625rem;
  font-weight: 700;
  line-height: 0.9375rem;
  min-width: 0.9375rem;
  border-radius: 8px;
  text-align: center;
}
.zi-badge.success {
  background-color: var(--geist-success);
}
.zi-badge.warning {
  background-color: var(--geist-warning);
}
.zi-badge.danger,
.zi-badge.error {
  background-color: var(--geist-error);
}
.zi-badge.dot {
  width: 0.375rem;
  height: 0.375rem;
  border-radius: 50%;
  padding: 0;
  min-width: unset;
  overflow: hidden;
  line-height: 0;
  color: transparent;
}
.zi-btn {
  -webkit-box-align: center;
  -webkit-align-items: center;
  display: inline-block;
  padding: 0 1.375rem;
  border-radius: var(--geist-radius);
  border: 1px solid var(--accents-2);
  font-weight: 400;
  font-size: 0.875rem;
  cursor: pointer;
  user-select: none;
  outline: none;
  justify-content: center;
  text-transform: uppercase;
  text-align: center;
  height: 2.5rem;
  line-height: 2.5rem;
  width: auto;
  min-width: 12.5rem;
  white-space: nowrap;
  transition: border 0.2s, background 0.2s, color 0.2s ease-out;
  position: relative;
  overflow: hidden;
  background-color: var(--geist-background);
  color: var(--accents-5);
}
.zi-btn:not(.loading):not(.shadow):hover {
  color: #000;
  background: #fff;
  border-color: #000;
}
.zi-btn.mini {
  height: 1.5rem;
  line-height: 1.5rem;
  padding: 0 1.375rem;
  width: auto;
  min-width: 5.25rem;
  font-size: 0.75rem;
}
.zi-btn.small {
  height: 2rem;
  line-height: 2rem;
  padding: 0 1.25rem;
  width: auto;
  min-width: 9.375rem;
  font-size: 0.875rem;
}
.zi-btn.big,
.zi-btn.huge,
.zi-btn.large {
  height: 2.75rem;
  line-height: 2.75rem;
  padding: 0 1.875rem;
  width: auto;
  min-width: 15.625rem;
  font-size: 1rem;
}
.zi-btn.primary {
  background-color: var(--geist-foreground);
  border: 1px solid var(--geist-foreground);
  color: var(--geist-background);
}
.zi-btn.primary:not(.loading):not(.shadow):hover {
  background: var(--geist-background);
  border: 1px solid var(--geist-foreground);
}
.zi-btn.warning {
  border-color: var(--geist-warning);
  background-color: var(--geist-warning);
  color: #fff;
}
.zi-btn.warning:not(.loading):not(.shadow):hover {
  color: var(--geist-warning);
  background: #fff;
  border-color: var(--geist-warning);
}
.zi-btn.danger,
.zi-btn.error {
  border-color: var(--geist-error);
  background-color: var(--geist-error);
  color: #fff;
}
.zi-btn.danger:not(.loading):not(.shadow):hover,
.zi-btn.error:not(.loading):not(.shadow):hover {
  color: var(--geist-error);
  background: #fff;
  border-color: var(--geist-error);
}
.zi-btn.success {
  border-color: var(--geist-success);
  background-color: var(--geist-success);
  color: #fff;
}
.zi-btn.success:not(.loading):not(.shadow):hover {
  color: var(--geist-success);
  background: #fff;
  border-color: var(--geist-success);
}
.zi-btn.abort,
.zi-btn.abort:not(.loading):not(.shadow):hover {
  background-color: transparent;
  border-color: transparent;
  color: var(--accents-5);
}
.zi-btn.shadow {
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.12);
}
.zi-btn.shadow:not(.loading):hover {
  box-shadow: 0 7px 20px rgba(0, 0, 0, 0.16);
  transform: translateY(-1px);
}
.zi-btn.disabled,
.zi-btn.disabled:hover {
  background: var(--accents-1) !important;
  border-color: var(--accents-2) !important;
  color: #ccc !important;
  cursor: not-allowed !important;
}
.zi-btn.loading {
  cursor: default;
}
.zi-btn.loading:hover {
  pointer-events: none;
  color: transparent;
}
.zi-loading-shim {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--accents-1);
}
.zi-loading-shim i {
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background-color: #444;
  margin: 0 1px;
  display: inline-block;
  animation: zi-loading-blink 1.4s infinite both;
}
.zi-loading-shim i:nth-child(2) {
  animation-delay: 0.2s;
}
.zi-loading-shim i:nth-child(3) {
  animation-delay: 0.4s;
}
.zi-btn .prefix,
.zi-btn .suffix {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  font-size: 1.5625rem;
  pointer-events: none;
}
.zi-btn .prefix {
  left: 0.5rem;
}
.zi-btn .suffix {
  right: 0.5rem;
}
.zi-btn.small .prefix,
.zi-btn.small .suffix {
  font-size: 0.875rem;
}
.zi-btn.auto {
  min-width: min-content;
  padding: 0 1.25rem;
}
.zi-btn.auto .mini {
  padding: 0 0.625rem;
}
.zi-btn.auto .small {
  padding: 0 0.9375rem;
}
.zi-btn.auto .big,
.zi-btn.auto .huge {
  padding: 0 1.5625rem;
}
@-moz-keyframes zi-loading-blink {
  0% {
    opacity: 0.2;
  }
  20% {
    opacity: 1;
  }
  to {
    opacity: 0.2;
  }
}
@-webkit-keyframes zi-loading-blink {
  0% {
    opacity: 0.2;
  }
  20% {
    opacity: 1;
  }
  to {
    opacity: 0.2;
  }
}
@-o-keyframes zi-loading-blink {
  0% {
    opacity: 0.2;
  }
  20% {
    opacity: 1;
  }
  to {
    opacity: 0.2;
  }
}
@keyframes zi-loading-blink {
  0% {
    opacity: 0.2;
  }
  20% {
    opacity: 1;
  }
  to {
    opacity: 0.2;
  }
}
pre {
  background-color: transparent;
  border: 1px solid var(--accents-2);
  border-radius: var(--geist-radius);
  padding: calc(var(--geist-gap) * 0.75) var(--geist-gap);
  margin: var(--geist-gap) 0;
  font-family: var(--font-mono);
  white-space: pre;
  overflow: auto;
  line-height: 1.5;
  text-align: left;
  font-size: 0.8125rem;
  -webkit-overflow-scrolling: touch;
}
pre.zi-bash:before {
  content: "$ ";
}
pre p,
pre span {
  font-size: inherit;
  color: inherit;
  margin: 0;
}
pre code {
  color: var(--geist-foreground);
  font-size: 0.8125rem;
  line-height: 1.25rem;
  white-space: pre;
}
pre code:after,
pre code:before {
  display: none;
}
pre::-webkit-scrollbar {
  display: none;
  width: 0;
  height: 0;
  background: transparent;
}
code {
  color: var(--geist-code);
  font-family: var(--font-mono);
  font-size: 0.9em;
  white-space: pre-wrap;
}
code:after,
code:before {
  content: "\`";
}
.zi-bash pre:before {
  content: "$ ";
}
.zi-fieldset {
  border: 1px solid var(--accents-2);
  border-radius: var(--geist-radius);
  overflow: hidden;
}
.zi-fieldset,
.zi-fieldset-content {
  background-color: var(--geist-background);
}
.zi-fieldset-content {
  font-size: 0.8125rem;
  padding: 1.25rem;
}
.zi-fieldset-content h1 {
  font-size: 1.25rem;
}
.zi-fieldset-content h2,
.zi-fieldset-content h3,
.zi-fieldset-content h4,
.zi-fieldset-content h5,
.zi-fieldset-content h6,
.zi-fieldset-content p,
.zi-fieldset-content span {
  font-size: 0.8125rem;
}
.zi-fieldset-content div,
.zi-fieldset-content h1,
.zi-fieldset-content h2,
.zi-fieldset-content h3,
.zi-fieldset-content h4,
.zi-fieldset-content h5,
.zi-fieldset-content h6,
.zi-fieldset-content p {
  margin-top: 0;
  line-height: 1.25rem;
  margin-bottom: 0.875rem;
}
.zi-fieldset-content :first-child {
  margin-top: 0;
}
.zi-fieldset-content :last-child {
  margin-bottom: 0;
}
.zi-fieldset-footer {
  background-color: var(--accents-1);
  border-top: 1px solid var(--accents-2);
  color: var(--accents-6);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.875rem;
  padding: var(--geist-gap-half) var(--geist-gap);
  box-sizing: border-box;
}
.zi-fieldset-footer div,
.zi-fieldset-footer p,
.zi-fieldset-footer span {
  font-size: inherit;
  margin: 0;
}
.zi-input {
  font-family: var(--font-sans);
  padding: 0 0.6875rem;
  display: inline-flex;
  vertical-align: middle;
  align-items: center;
  border-radius: var(--geist-radius);
  background-color: transparent;
  font-size: 0.875rem;
  height: 2.3125rem;
  line-height: 1.6875rem;
  width: auto;
  outline: 0;
  box-sizing: border-box;
  margin: 4px 10px;
  border: 1px solid var(--accents-2);
  -webkit-appearance: none;
  transition: border 0.2s ease, color 0.2s ease;
}
.zi-input:focus {
  border-color: var(--accents-5);
}
.zi-input.disabled {
  background: var(--accents-1);
  cursor: not-allowed;
}
.zi-input.error {
  color: var(--geist-error);
  border-color: var(--geist-error);
}
.zi-input.success {
  color: var(--geist-success);
  border-color: var(--geist-success);
}
.zi-input.small {
  font-size: 0.75rem;
  height: 2rem;
  line-height: 1.375rem;
}
.zi-input.mini {
  font-size: 0.75rem;
  height: 1.75rem;
  line-height: 1.25rem;
}
.zi-input.big,
.zi-input.huge {
  font-size: 1rem;
  height: 2.625rem;
  line-height: 2.375rem;
}
.zi-input-group-empty {
  display: inline-flex;
  border-radius: var(--geist-radius);
  background-color: transparent;
}
.zi-input-group-empty input {
  flex: 1;
  margin: 0;
}
.zi-input-group {
  display: inline-flex;
  border-radius: var(--geist-radius);
  background-color: transparent;
}
.zi-input-group input {
  flex: 1;
  margin: 0;
}
.zi-input-group > .zi-label {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  background-color: var(--accents-1);
  border-radius: var(--geist-radius);
  border-bottom: 1px solid var(--accents-2);
  border-top: 1px solid var(--accents-2);
  color: var(--accents-6);
  font-size: 0.875rem;
  line-height: 1;
  width: auto;
  padding: 0 0.625rem;
  user-select: none;
}
.zi-input-group > .zi-label i {
  margin: 0 0.25rem;
}
.zi-input-group.suffix input {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.zi-input-group.suffix > .zi-label.suffix {
  border-left: none;
  border-right: 1px solid var(--accents-2);
}
.zi-input-group.prefix input,
.zi-input-group.suffix > .zi-label.suffix {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.zi-input-group.prefix > .zi-label.prefix {
  border-right: none;
  border-left: 1px solid var(--accents-2);
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.zi-input-group-empty.clearable,
.zi-input-group.clearable {
  position: relative;
}
.zi-input-group-empty.clearable input,
.zi-input-group.clearable input {
  padding-right: 1.75rem;
}
.zi-input-group-empty.clearable i.close,
.zi-input-group.clearable i.close {
  color: #9b9b9b;
  font-size: inherit;
  position: absolute;
  top: 50%;
  right: 0.375rem;
  padding: 0 0.3125rem;
  transform: translateY(-50%) scale(1.45);
  z-index: 1;
  background-color: transparent;
  cursor: pointer;
  transition: all 0.15s ease;
}
.zi-note {
  padding: var(--geist-gap-half) var(--geist-gap);
  font-size: 0.875rem;
  line-height: 1.8;
  border: 1px solid var(--accents-2);
  background-color: var(--geist-background);
  border-radius: var(--geist-radius);
}
.zi-note .zi-note-type {
  text-transform: uppercase;
  user-select: none;
  line-height: 1.5;
  padding-right: var(--geist-gap-quarter);
  font-weight: 600;
  font-size: 0.875rem;
}
.zi-note.hint,
.zi-note.success {
  border-color: var(--geist-success);
}
.zi-note.hint > .zi-note-type,
.zi-note.success > .zi-note-type {
  color: var(--geist-success);
}
.zi-note.alert,
.zi-note.warning {
  border-color: var(--geist-warning);
}
.zi-note.alert > .zi-note-type,
.zi-note.warning > .zi-note-type {
  color: var(--geist-warning);
}
.zi-note.danger,
.zi-note.error {
  border-color: var(--geist-error);
}
.zi-note.danger > .zi-note-type,
.zi-note.error > .zi-note-type {
  color: var(--geist-error);
}
table {
  border-collapse: separate;
  border-spacing: 0;
  width: 100%;
}
table thead th td {
  height: 2.5rem;
}
table tbody tr td {
  height: 3.125rem;
}
table td,
table th {
  padding: 0 0.625rem;
  text-align: left;
}
table th {
  height: 2.5rem;
  color: var(--accents-5);
  font-size: 0.875rem;
  font-weight: 400;
  letter-spacing: 0;
  background: var(--accents-1);
}
table th,
table th:first-child {
  border-bottom: 1px solid var(--accents-2);
  border-top: 1px solid var(--accents-2);
}
table th:first-child {
  border-left: 1px solid var(--accents-2);
  border-radius: 4px 0 0 4px;
}
table th:last-child {
  border-radius: 0 4px 4px 0;
  border-right: 1px solid var(--accents-2);
  border-top: 1px solid var(--accents-2);
}
table th:last-child,
table tr td {
  border-bottom: 1px solid var(--accents-2);
}
table tr td {
  color: var(--accents-6);
  font-size: 0.875rem;
  height: 2.5rem;
}
table td:first-child {
  border-left: 1px solid transparent;
}
.zi-avatar {
  display: inline-block;
  position: relative;
  overflow: hidden;
  width: 1.875rem;
  height: 1.875rem;
  border-radius: 50%;
  border: 1px solid var(--accents-2);
  vertical-align: top;
  background-color: var(--geist-background);
}
.zi-avatar img {
  display: inline-block;
  width: 100%;
  height: 100%;
  border-radius: 50%;
}
.zi-avatar + .zi-avatar {
  margin-left: 0;
}
.zi-avatar.small {
  width: 1.25rem;
  height: 1.25rem;
}
.zi-avatar.big {
  width: 3.75rem;
  height: 3.75rem;
}
.zi-avatar.big .zi-avatar-string {
  font-size: 1.25rem;
}
.zi-avatar.huge {
  width: 5.625rem;
  height: 5.625rem;
}
.zi-avatar.huge .zi-avatar-string {
  font-size: 1.25rem;
}
.zi-avatar.stacked + .zi-avatar.stacked {
  margin-left: -0.625rem;
}
.zi-avatar.square,
.zi-avatar.square img {
  border-radius: 0.3125rem;
}
.zi-avatar.single .zi-avatar-string {
  transform: translate(-50%, -50%) scale(1);
}
.zi-avatar-string {
  position: absolute;
  left: 50%;
  top: 50%;
  font-size: 0.875rem;
  text-align: center;
  transform: translate(-50%, -50%) scale(0.6);
  white-space: nowrap;
  user-select: none;
}
.zi-example {
  background: var(--accents-1);
  display: flex;
  flex-direction: column;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  border-radius: 4px;
}
.zi-tag {
  display: inline-block;
  line-height: 1.5rem;
  height: 1.5rem;
  font-size: 0.75rem;
  border-radius: var(--geist-radius);
  border: 1px solid var(--accents-2);
  font-weight: 500;
  background-color: var(--accents-1);
  padding: 0 0.5rem;
}
.zi-tag.success {
  color: var(--geist-success);
}
.zi-tag.warning {
  color: var(--geist-warning);
}
.zi-tag.danger,
.zi-tag.error {
  color: var(--geist-error);
}
.zi-spinner {
  display: block;
  width: 1.25rem;
  height: 1.25rem;
}
.zi-spinner.small {
  width: 1rem;
  height: 1rem;
}
.zi-spinner.small .zi-spinner-bar {
  width: 0.25rem;
  height: 0.0625rem;
}
.zi-spinner.mini {
  width: 0.75rem;
  height: 0.75rem;
}
.zi-spinner.mini .zi-spinner-bar {
  width: 0.1875rem;
  height: 0.0625rem;
}
.zi-spinner.big {
  width: 1.875rem;
  height: 1.875rem;
}
.zi-spinner.big .zi-spinner-bar {
  width: 0.4375rem;
  height: 0.1875rem;
}
.zi-spinner.auto {
  width: 100%;
  height: 100%;
}
.zi-spinner.auto .zi-spinner-bar {
  width: 24%;
  height: 8%;
}
.zi-spinner-container {
  width: 100%;
  height: 100%;
  position: relative;
  left: 50%;
  top: 50%;
}
.zi-spinner-bar {
  background-color: #000;
  position: absolute;
  top: -3.9%;
  left: -10%;
  width: 0.3125rem;
  height: 0.1rem;
  border-radius: var(--geist-radius);
  animation: zi-spinner-spin 1.2s linear 0s infinite normal none running;
}
.zi-spinner-bar:first-child {
  animation-delay: -1.2s;
  transform: rotate(0deg) translate(146%);
}
.zi-spinner-bar:nth-child(2) {
  animation-delay: -1.1s;
  transform: rotate(30deg) translate(146%);
}
.zi-spinner-bar:nth-child(3) {
  animation-delay: -1s;
  transform: rotate(60deg) translate(146%);
}
.zi-spinner-bar:nth-child(4) {
  animation-delay: -0.9s;
  transform: rotate(90deg) translate(146%);
}
.zi-spinner-bar:nth-child(5) {
  animation-delay: -0.8s;
  transform: rotate(120deg) translate(146%);
}
.zi-spinner-bar:nth-child(6) {
  animation-delay: -0.7s;
  transform: rotate(150deg) translate(146%);
}
.zi-spinner-bar:nth-child(7) {
  animation-delay: -0.6s;
  transform: rotate(180deg) translate(146%);
}
.zi-spinner-bar:nth-child(8) {
  animation-delay: -0.5s;
  transform: rotate(210deg) translate(146%);
}
.zi-spinner-bar:nth-child(9) {
  animation-delay: -0.4s;
  transform: rotate(240deg) translate(146%);
}
.zi-spinner-bar:nth-child(10) {
  animation-delay: -0.3s;
  transform: rotate(270deg) translate(146%);
}
.zi-spinner-bar:nth-child(11) {
  animation-delay: -0.2s;
  transform: rotate(300deg) translate(146%);
}
.zi-spinner-bar:nth-child(12) {
  animation-delay: -0.1s;
  transform: rotate(330deg) translate(146%);
}
@-moz-keyframes zi-spinner-spin {
  0% {
    opacity: 1;
  }
  to {
    opacity: 0.15;
  }
}
@-webkit-keyframes zi-spinner-spin {
  0% {
    opacity: 1;
  }
  to {
    opacity: 0.15;
  }
}
@-o-keyframes zi-spinner-spin {
  0% {
    opacity: 1;
  }
  to {
    opacity: 0.15;
  }
}
@keyframes zi-spinner-spin {
  0% {
    opacity: 1;
  }
  to {
    opacity: 0.15;
  }
}
.zi-fade-in-enter-active,
.zi-fade-in-leave-active {
  transition: opacity 0.2s ease 0s, margin-top 0.2s ease 0s;
}
.zi-fade-in-enter,
.zi-fade-in-leave,
.zi-fade-in-leave-active {
  opacity: 0;
  margin-top: 5px;
}

    </style>

    <style>
        dialog {
  position: absolute;
  left: 0;
  right: 0;
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
  height: -moz-fit-content;
  height: -webkit-fit-content;
  height: fit-content;
  margin: auto;
  border: solid;
  padding: 1em;
  background: white;
  color: black;
  display: block;
}

dialog:not([open]) {
  display: none;
}

dialog + .backdrop {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: rgba(0, 0, 0, 0.1);
}

._dialog_overlay {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

dialog.fixed {
  position: fixed;
  top: 50%;
  transform: translate(0, -50%);
}

    </style>

    <style>
        * {
  box-sizing: border-box;
  transition: all 0.2s ease-in-out;
  font-family: sans-serif;
}

body {
  margin: 0 auto;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}

form {
  padding: 4em 0;
}

    </style>
</head>
<body>
    <main>
        <h2>LinksBook Log-In</h2>
        <div class="zi-card shadow">
            <input id="create-login-email" class="zi-input" type="email" placeholder="kylee@example.com" />
            <button id="create-login-action" class="zi-btn primary small auto">
                Log In
            </button>
        </div>
        <dialog id="pin-dialog">
            <input id="pin-dialog-pin" class="zi-input" type="text" placeholder="Login Pin" />
            <button id="validate-pin" class="zi-btn primary small auto">
                Log In
            </button>
        </dialog>
    </main>
</body>
</html>